name: Deploy to EC2

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
        default: "dev"
      aws_region:
        description: 'AWS region to deploy to'
        required: true
        type: string
        default: "eu-north-1"
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      instance_ip:
        description: 'EC2 instance IP address'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    # These permissions are needed to interact with GitHub's OIDC Token endpoint
    permissions:
      id-token: write  # Required for requesting the JWT
      contents: read   # Required for actions/checkout
    env:
      AWS_REGION: ${{ inputs.aws_region }}
      ENVIRONMENT: ${{ inputs.environment }}
      SECRETS_PREFIX: "/${{ inputs.environment }}/backend"
      IMAGE_TAG: ${{ inputs.image_tag }}
      INSTANCE_IP: ${{ inputs.instance_ip }}
      INSTANCE_ID: ${{ vars.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Get secrets from AWS Secrets Manager
        id: secrets
        run: |
          # Fetch database URL
          DATABASE_URL_SECRET=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRETS_PREFIX }}/DATABASE_URL" --query SecretString --output text || echo "")
          if [ -z "$DATABASE_URL_SECRET" ]; then
            echo "Using DATABASE_URL from GitHub secrets as fallback"
            DATABASE_URL="${{ secrets.DATABASE_URL }}"
          else
            echo "Using DATABASE_URL from AWS Secrets Manager"
            DATABASE_URL="$DATABASE_URL_SECRET"
          fi

          # Fetch Supabase URL
          SUPABASE_URL_SECRET=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRETS_PREFIX }}/SUPABASE_URL" --query SecretString --output text || echo "")
          if [ -z "$SUPABASE_URL_SECRET" ]; then
            echo "Using SUPABASE_URL from GitHub secrets as fallback"
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
          else
            echo "Using SUPABASE_URL from AWS Secrets Manager"
            SUPABASE_URL="$SUPABASE_URL_SECRET"
          fi

          # Fetch Supabase service role key
          SUPABASE_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRETS_PREFIX }}/SUPABASE_SERVICE_ROLE_KEY" --query SecretString --output text || echo "")
          if [ -z "$SUPABASE_KEY_SECRET" ]; then
            echo "Using SUPABASE_SERVICE_ROLE_KEY from GitHub secrets as fallback"
            SUPABASE_KEY="${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
          else
            echo "Using SUPABASE_SERVICE_ROLE_KEY from AWS Secrets Manager"
            SUPABASE_KEY="$SUPABASE_KEY_SECRET"
          fi

          # Store secrets securely in environment variables
          echo "DATABASE_URL=$DATABASE_URL" >> $GITHUB_ENV
          echo "SUPABASE_URL=$SUPABASE_URL" >> $GITHUB_ENV
          echo "SUPABASE_KEY=$SUPABASE_KEY" >> $GITHUB_ENV

      - name: Create deployment files
        id: create-files
        run: |
          # Create a temporary directory for deployment files
          DEPLOY_DIR=$(mktemp -d)
          echo "deploy_dir=$DEPLOY_DIR" >> $GITHUB_OUTPUT

          # Create docker-compose.yml
          cat > $DEPLOY_DIR/docker-compose.yml << EOL
          version: '3'
          services:
            backend:
              image: ${{ steps.login-ecr.outputs.registry }}/vista-backend-${{ env.ENVIRONMENT }}:${{ env.IMAGE_TAG }}
              ports:
                - "80:8000"
              restart: always
              environment:
                - DATABASE_URL=${{ env.DATABASE_URL }}
                - SUPABASE_URL=${{ env.SUPABASE_URL }}
                - SUPABASE_SERVICE_ROLE_KEY=${{ env.SUPABASE_KEY }}
                - ENVIRONMENT=${{ env.ENVIRONMENT }}
          EOL

          # Create deployment script
          cat > $DEPLOY_DIR/deploy.sh << 'EOL'
          #!/bin/bash
          set -e

          # Login to ECR
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}

          mkdir -p ~/project-vista-app
          cd ~/project-vista-app

          # Copy docker-compose file
          cp /tmp/ssm-deployment/docker-compose.yml ./docker-compose.yml

          # Pull and start containers
          docker-compose pull
          docker-compose down || true
          docker-compose up -d

          echo "Deployment completed successfully"
          EOL

          chmod +x $DEPLOY_DIR/deploy.sh

      - name: Deploy to EC2 using SSM
        run: |
          # Upload deployment files to S3
          BUCKET_NAME="vista-deployment-${RANDOM}"
          aws s3api create-bucket --bucket $BUCKET_NAME \
            --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }} \
            --region ${{ env.AWS_REGION }} || true

          aws s3 cp ${{ steps.create-files.outputs.deploy_dir }}/docker-compose.yml s3://$BUCKET_NAME/docker-compose.yml
          aws s3 cp ${{ steps.create-files.outputs.deploy_dir }}/deploy.sh s3://$BUCKET_NAME/deploy.sh

          # Create and run SSM document for deployment
          aws ssm send-command \
            --instance-ids "${{ env.INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[ \
              \"mkdir -p /tmp/ssm-deployment\", \
              \"aws s3 cp s3://$BUCKET_NAME/docker-compose.yml /tmp/ssm-deployment/docker-compose.yml\", \
              \"aws s3 cp s3://$BUCKET_NAME/deploy.sh /tmp/ssm-deployment/deploy.sh\", \
              \"chmod +x /tmp/ssm-deployment/deploy.sh\", \
              \"ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }} AWS_REGION=${{ env.AWS_REGION }} /tmp/ssm-deployment/deploy.sh\" \
            ]" \
            --output text \
            --cloud-watch-output-config CloudWatchOutputEnabled=true \
            --region ${{ env.AWS_REGION }}

          # Wait for command to complete (up to 5 minutes)
          echo "Waiting for deployment to complete..."
          sleep 30

          # Clean up S3 bucket
          aws s3 rm s3://$BUCKET_NAME --recursive || true
