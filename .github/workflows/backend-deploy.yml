name: Deploy to EC2

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
        default: "dev"
      aws_region:
        description: 'AWS region to deploy to'
        required: true
        type: string
        default: "eu-north-1"
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      instance_ip:
        description: 'EC2 instance IP address'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    # These permissions are needed to interact with GitHub's OIDC Token endpoint
    permissions:
      id-token: write  # Required for requesting the JWT
      contents: read   # Required for actions/checkout
    env:
      AWS_REGION: ${{ inputs.aws_region }}
      ENVIRONMENT: ${{ inputs.environment }}
      SECRETS_PREFIX: "/${{ inputs.environment }}/backend"
      IMAGE_TAG: ${{ inputs.image_tag }}
      INSTANCE_IP: ${{ inputs.instance_ip }}
      INSTANCE_ID: ${{ vars.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: true

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Get secrets from AWS Secrets Manager
        id: secrets
        run: |
          # Fetch database URL
          DATABASE_URL_SECRET=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRETS_PREFIX }}/DATABASE_URL" --query SecretString --output text || echo "")
          if [ -z "$DATABASE_URL_SECRET" ]; then
            echo "Using DATABASE_URL from GitHub secrets as fallback"
            DATABASE_URL="${{ secrets.DATABASE_URL }}"
          else
            echo "Using DATABASE_URL from AWS Secrets Manager"
            DATABASE_URL="$DATABASE_URL_SECRET"
          fi

          # Fetch Supabase URL
          SUPABASE_URL_SECRET=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRETS_PREFIX }}/SUPABASE_URL" --query SecretString --output text || echo "")
          if [ -z "$SUPABASE_URL_SECRET" ]; then
            echo "Using SUPABASE_URL from GitHub secrets as fallback"
            SUPABASE_URL="${{ secrets.SUPABASE_URL }}"
          else
            echo "Using SUPABASE_URL from AWS Secrets Manager"
            SUPABASE_URL="$SUPABASE_URL_SECRET"
          fi

          # Fetch Supabase service role key
          SUPABASE_KEY_SECRET=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRETS_PREFIX }}/SUPABASE_SERVICE_ROLE_KEY" --query SecretString --output text || echo "")
          if [ -z "$SUPABASE_KEY_SECRET" ]; then
            echo "Using SUPABASE_SERVICE_ROLE_KEY from GitHub secrets as fallback"
            SUPABASE_KEY="${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"
          else
            echo "Using SUPABASE_SERVICE_ROLE_KEY from AWS Secrets Manager"
            SUPABASE_KEY="$SUPABASE_KEY_SECRET"
          fi

          # Store secrets securely in environment variables
          echo "DATABASE_URL=$DATABASE_URL" >> $GITHUB_ENV
          echo "SUPABASE_URL=$SUPABASE_URL" >> $GITHUB_ENV
          echo "SUPABASE_KEY=$SUPABASE_KEY" >> $GITHUB_ENV

      - name: Deploy to EC2 using SSM
        run: |
          # Create docker-compose content as a variable
          DOCKER_COMPOSE_CONTENT=$(cat << EOF
          version: '3'
          services:
            backend:
              image: ${{ steps.login-ecr.outputs.registry }}/vista-backend-${{ env.ENVIRONMENT }}:${{ env.IMAGE_TAG }}
              ports:
                - "80:8000"
              restart: always
              environment:
                - DATABASE_URL=${{ env.DATABASE_URL }}
                - SUPABASE_URL=${{ env.SUPABASE_URL }}
                - SUPABASE_SERVICE_ROLE_KEY=${{ env.SUPABASE_KEY }}
                - ENVIRONMENT=${{ env.ENVIRONMENT }}
          EOF
          )

          # Escape the content for JSON
          DOCKER_COMPOSE_CONTENT_ESCAPED=$(echo "$DOCKER_COMPOSE_CONTENT" | jq -Rs .)

          # Create the deployment script as a variable
          DEPLOY_SCRIPT=$(cat << 'EOF'
          #!/bin/bash
          set -e

          # Login to ECR
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}

          mkdir -p ~/project-vista-app
          cd ~/project-vista-app

          # Create docker-compose.yml file
          echo "${DOCKER_COMPOSE_CONTENT}" > docker-compose.yml

          # Pull and start containers
          docker-compose pull
          docker-compose down || true
          docker-compose up -d

          echo "Deployment completed successfully"
          EOF
          )

          # Escape the script for JSON
          DEPLOY_SCRIPT_ESCAPED=$(echo "$DEPLOY_SCRIPT" | jq -Rs .)

          # Create the SSM document parameters
          SSM_PARAMS=$(cat << EOF
          {
            "commands": [
              "mkdir -p ~/project-vista-app",
              "cd ~/project-vista-app",
              "cat > docker-compose.yml << 'EOL'\n${DOCKER_COMPOSE_CONTENT}\nEOL",
              "export AWS_REGION=${{ env.AWS_REGION }}",
              "export ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}",
              "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
              "docker-compose pull",
              "docker-compose down || true",
              "docker-compose up -d",
              "echo 'Deployment completed successfully'"
            ]
          }
          EOF
          )

          # Run the SSM command
          aws ssm send-command \
            --instance-ids "${{ env.INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "$SSM_PARAMS" \
            --output text \
            --cloud-watch-output-config CloudWatchOutputEnabled=true \
            --region ${{ env.AWS_REGION }}

          echo "Deployment command sent to instance ${{ env.INSTANCE_ID }}"
